行锁是在引擎层由引擎自己实现的。**减少锁冲突对于提高并发度非常非常重要。**

Innodb 中，行锁在需要的时候加上，在事务提交的时候释放。

如果事务里要锁多个行，尽量把最可能造成锁冲突的锁（最可能被集中并发修改的）放在后面。

## 死锁

我遇到过一次死锁，是事务 A acquire 了一个间隙锁 L1，然后再加了个行锁 L2，而事务 B 则先加了行锁 L2，然后又 acquire 到了同一段间隙锁。

当死锁出现后，有两种策略：
一种是直接进入等待，直到超时，超时时间可以通过 innodb_lock_wait_timeout 来设置。 (默认是 50s)
另外一种是发起死锁检测，发现死锁后，主动回滚死锁链条中的某个事务，让其他事务可以继续。通过将 innodb_deadlock_detect 设置为 on 来开启死锁检测。（innodb 默认开启死锁检测）
通常来说，等 50s 显然是不可接受的，但是我们也不能把这个时间改太小（误伤普通的锁等待）。所以通常来说我们需要依赖死锁检测。

## 死锁检测的问题

你在做一个低价秒杀活动，但是在活动一开始的时候 mysql 就挂了，去服务器一看，cpu 消耗接近 100%,但数据库 TPS 不到 100，这是什么原因？

很可能是因为你开了死锁检测，并且出现了锁等待。在有死锁检测的情况下，即使不是死锁，每个被堵住的线程都要判断是不是由于自己的加入导致了死锁。这是一个 O(n \* n)的操作。并发度高的情况下非常吃 CPU。

解决方案有： 1. 关闭死锁检测，但这几乎是做不到的，可能出现大量超时。**2. 控制并发度。3. 在业务上降低并发冲突，比如把原来并发更新一行分流到不同的行上去（类似把一个账户拆成十个账户）。**

通常情况下，控制并发度是比较容易的一个方案
