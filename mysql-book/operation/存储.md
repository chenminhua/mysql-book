# 07.表空间

SELECT \* FROM information_schema.Tables;

show table status like 'table_name';

SHOW variables like '%innodb_file_per_table%'; 如果为 on 则每个表有独立的表空间。回滚信息，插入缓冲索引，系统事务信息，二次写缓冲等等数据还是放在共享表空间中。

SHOW VARIABLES WHERE Variable_Name = "datadir"; 查看数据目录

ls -lh /var/lib/mysql/ibdata1 查看共享表空间大小

### 页

innodb_page_size， 默认 16k。
分页：数据页,undo 页，系统页，事务数据页。
页是通过双向链表来连接的。每个页中至少有两条行记录！！
记录太大，一页存不下怎么办？行溢出的时候，数据存在页类型为 uncompress blob 页中

### 区

区是连续页的集合，大小为 1M。为了保持区中页的连续性，通常一次从磁盘拿出 4~5 个分区。
默认情况下，页大小为 16kb(可以通过 innodb_page_size 进行调整)，一个区中有 64 个连续的页。

### 段

数据段：树的叶子节点
索引段：树的非叶子节点
回滚段

### 行

什么是行溢出？

## 13 | 为什么表数据删掉一半，表文件大小不变？

假设，我们要删掉一条记录，InnoDB 引擎只会把这个记录标记为删除。但是，磁盘文件的大小并不会缩小。如果我们删掉了一个数据页上的所有记录，整个数据页就可以被复用了。

注意，**数据页的复用跟记录的复用是不同的。**记录的复用只限于符合范围条件的数据。而页复用则可以复用到任何位置。

如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。如果我们用 delete 命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。这些可以复用，而没有被使用的空间，看起来就像是**空洞**。

实际上，**不止是删除数据会造成空洞，插入数据也会。**如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的**数据页分裂**。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。

## 重建表

alter table A engine=InnoDB

mysql 5.5 之前，这个 DDL 不是 online 的，会停止所有更新。而在**MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。**

1.  建立一个临时文件，扫描表 A 主键的所有数据页；
2.  用数据页中表 A 的记录生成 B+树，存储到临时文件中；
3.  生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
4.  临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
5.  用临时文件替换表 A 的数据文件。

对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。

需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，你要很小心地控制操作时间。**如果想要比较安全的操作的话，我推荐你使用 GitHub 开源的 gh-ost 来做。**

# Online 和 inplace

说到 Online，我还要再和你澄清一下它和另一个跟 DDL 有关的、容易混淆的概念 inplace 的区别。

你可能注意到了，在图 3 中，我们把表 A 中的数据导出来的存放位置叫作 tmp_table。这是一个临时表，是在 server 层创建的。

在图 4 中，根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。

我们重建表的这个语句 alter table t engine=InnoDB，其实隐含的意思是：
alter table t engine=innodb,ALGORITHM=inplace;

跟 inplace 对应的就是拷贝表的方式了，用法是：
alter table t engine=innodb,ALGORITHM=copy;

当你使用 ALGORITHM=copy 的时候，表示的是强制拷贝表，对应的流程就是图 3 的操作过程。

但我这样说你可能会觉得，inplace 跟 Online 是不是就是一个意思？

其实不是的，只是在重建表这个逻辑中刚好是这样而已。

比如，如果我要给 InnoDB 表的一个字段加全文索引，写法是：

    alter table t add FULLTEXT(field_name);

这个过程是 inplace 的，但会阻塞增删改操作，是非 Online 的。

如果说这两个逻辑之间的关系是什么的话，可以概括为：

1.  DDL 过程如果是 Online 的，就一定是 inplace 的；
2.  反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。

analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；

optimize table t 等于 recreate+analyze。
