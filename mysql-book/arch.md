## server 层

server 包括连接器，查询缓存，分析器，优化器，执行器等等。Mysql 的大多数核心服务，所有内置函数（e.g.日期，时间，加密），存储过程，trigger，视图等等，所有跨存储引擎的功能都在 server 层实现。

#### 连接器： 管理连接，权限验证

1. 连接完成后，连接会处于空闲状态，你可以通过 show processlist 看到所有连接。

2. 连接太长时间没动静，连接器会自动将其断开，该时间由 wait_timeout 控制，默认 8 小时。

```
show session variables like "%wait_timeout%”
```

3. 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。**建议多使用长连接。**

4. 但是全部使用长连接后，mysql 内存有时候涨的很快，这是因为 Mysql 在执行过程中临时使用的内存是管理在连接对象里的，这些资源在连接断开时才会释放。为了解决这个问题，我们可以考虑两种方案：1. 定期断开长连接。2. 如果是使用 mysql5.7 或更新版本，可以在每次执行一个较大的操作后，执行 mysql_reset_connection.

#### 分析器： 词法分析，语法分析

分析器会分析你要干嘛，你的 sql 语句是否合法。同时，分析 sql 的执行情况也是分析器干的。

#### 优化器： 生成执行计划，选择索引

优化器会决定使用哪个索引；或者在一个语句有多个 join 的时候决定 join 的顺序（哪个做驱动表哪个做被驱动表）。

优化器选择索引的逻辑是：最小代价去执行语句。而扫描行数是一个关键因素，除此之外，优化器还会根据是否需要用临时表，是否排序等因素来判断。

优化器根据索引区分度来估算扫描行数，cardinality 越大，区分度越好。使用 show index 可以看到 cardinality。MySQL 通过采样统计估计 cardinality，默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。

索引统计值（cardinality 列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。
接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。

解决方案： analyze table t 命令，可以用来重新统计索引信息。

大多数时候优化器都能找到正确索引，但是有时候原本应该很快的 sql 却执行得很慢，怎么办？

一种方法是直接 force index 强行选择一个索引，但是这会带来开发上的问题。另一种方法是通过引导优化器是否需要排序等方法来帮助优化器选择正确的索引，这种方法也不具有通用性。第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。

#### 执行器： 与存储引擎交互

先判断你有没有执行权限，没有的话就直接返回没有权限的错误。如果有权限，就打开表开始执行。
打开表的时候，执行器会根据表的引擎定义，去使用这个引擎提供的接口。
没有使用到索引的时候，执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
   对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
   你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。
   在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。

## 存储引擎

而存储引擎负责数据的存储和提取，其架构模式是插件式的，默认是 innodb。
