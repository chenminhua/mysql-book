进程都认为自己独享内存空间。操作系统提供一种机制，将不同进程的虚拟地址和不同的内存物理地址映射起来。当程序要访问虚拟地址的时候，由内核的内存管理模块转换为物理地址。

真正能够访问物理内存的，只有内存管理系统，其他程序不论内核态还是用户态都不能直接访问物理内存，而是访问虚拟地址。

## 规划虚拟地址空间

- 物理内存的管理
- 虚拟内存地址的管理
- 虚拟地址与物理地址的映射

虚拟地址到物理地址的映射表，是内存管理模块的一部分，那么这个部分是“实”的还是“虚”的？

从虚拟地址角度，对于 64 位机器的进程来说（其实是 48 位），它认为自己有 256T 内存空间（32 位机器认为是 4G）。这么大空间一分为二，一部分内核空间一部分用户空间。内核空间在高地址位，用户进程是不能访问内核空间内存的。

- 我们从内存低地址开始看起，首先是代码段，数据段，BSS 段（未初始化的静态变量），这三部分都是从二进制文件中加载来的。
- 接下来是堆，堆是从低地址往高地址增长的。
- 接下来是 mmap。这块地址用于将文件映射到内存使用。比如 so 文件。
- 再往高位就是栈。
- 再往高就是内核空间。

代码段 - 数据段 - BSS 段 - 堆 - mmap - 栈 - 内核空间。

到了内核空间，无论哪个进程进来，看到的都是同一个进程列表，里面存着进程列表，内核线程等等。访问这些公共的数据结构，需要进行锁保护。

## 内存的分段机制

分段机制下虚拟地址由两个部分组成，段选择子和段内偏移量。

## 内存的分页机制

linux 采用分页机制来实现从虚拟地址到物理地址的转换。
操作系统将物理地址分成一块块大小相同的页来管理。

## mmap 的原理

如果我们要在堆上申请小块内存，就用 brk。如果申请一块大内存，就用 mmap。对于堆的申请来说，mmap 是映射内存空间到物理空间。此外，如果一个进程想要映射一个文件到自己的虚拟内存，也要通过 mmap。这时 mmap 是映射内存空间到物理内存再到文件。

```c
// 查看 include/linux/mm_types.h
// 每个进程都有一个列表vm_area_struct，指向虚拟地址空间的不同内存块。
// 内存映射不仅是物理内存到虚拟内存，还包括将文件中的内容映射到虚拟内存空间。
// 这时候访问内存空间就能够访问到文件里面的数据（当然，也是通过了物理内存的）。
struct mm_struct {
  struct vm_area_struct *mmap;    /* list of VMAs */
}

struct vm_area_struct {

	unsigned long vm_start;
	unsigned long vm_end;

	/* linked list of VM areas per task, sorted by address */
	struct vm_area_struct *vm_next, *vm_prev;

	struct rb_node vm_rb;

	/*
	 * Largest free memory gap in bytes to the left of this VMA.
	 * Either between this VMA and vma->vm_prev, or between one of the
	 * VMAs below us in the VMA rbtree and its ->vm_prev. This helps
	 * get_unmapped_area find a free area of the right size.
	 */
	unsigned long rb_subtree_gap;

	struct mm_struct *vm_mm;	/* The address space we belong to. */
	pgprot_t vm_page_prot;		/* Access permissions of this VMA. */
	unsigned long vm_flags;		/* Flags, see mm.h. */

	struct {
		struct rb_node rb;
		unsigned long rb_subtree_last;
	} shared;

	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;

	/* Function pointers to deal with this struct. */
	const struct vm_operations_struct *vm_ops;

	/* Information about our backing store: */
	unsigned long vm_pgoff;
	struct file * vm_file;		/* File we map to (can be NULL). */
	void * vm_private_data;		/* was vm_pte (shared mem) */
}
```

```c
// arch/arm64/kernel/sys.c
SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,
		unsigned long, prot, unsigned long, flags,
		unsigned long, fd, unsigned long, off)
{
	if (offset_in_page(off) != 0)
		return -EINVAL;

	return ksys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
}

// mm/mmap.c
SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,
		unsigned long, prot, unsigned long, flags,
		unsigned long, fd, unsigned long, pgoff)
{
	return ksys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);
}
```

如果要映射到文件，则会传一个文件描述符进来，mmap_pgoff 里面通过 fget 函数获取并打开文件。接下来的调用链是 vm_mmap_pgoff -> mmap_pgoff -> do_mmap。

然后调用 get_unmapped_area 找到一个没有映射的区域，并调用 mmap_region 映射这个区域。

## 用户态缺页异常

一旦开始访问虚拟内存的某个地址，但没有对应的物理页，就触发缺页异常，调用 do_page_fault。在\_\_do_page_fault 里先判断中断是否发生在内核。如果发生在内核则调用 vmalloc_fault。如果是在用户空间里面，就找到你访问的那个地址所在的区域 vm_area_struct，然后调用 handle_mm_fault 来映射这个区域。

## NUMA

处理器的 NUMA(Non-Uniform Memory Access，非一致性内存访问)架构，多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地空间。而同一个 Node 内部的内存空间，实际上又可以进一步分为不同的 zone，比如直接内存访问区(DMA)、普通内存区(NORMAL)、伪内存区(MOVABLE)等。

```sh
apt install numactl
numactl --hardware
```

## Swap

Swap 就是把一块磁盘空间或者一个本地文件当成内存来用，包含换入和换出两个过程。swap 把系统的可用内存变大了。常见的笔记本电脑休眠和快速开机的功能，就是基于 swap 的。

Linux 在内存不足以分配新的大块内存的时候，会发生 swap，以回收部分内存。此外，linux 还有一个专门的内核线程 kswapd0 来定期回收内存。

开启 Swap 后，你可以设置 /proc/sys/vm/min_free_kbytes ，来调整系统定期回收内存的阈值，也可以设置 /proc/sys/vm/swappiness ，来调整文件页和匿名页的回收倾向。

https://time.geekbang.org/column/article/75973

通常来说，降低 swap 的使用可以提高系统的整体性能。现在服务器内存都足够大，除非有必要，一般都应该禁用 swap。如果实在需要用到 swap，可以尝试降低 swappiness 的值，减少内存回收时 swap 的使用倾向。

响应延迟敏感的应用，如果它们可能在开启 swap 的服务器中运行，则可以用 mlock 或者 mlockall()锁定内存，阻止内存换出。

```sh
查看系统swappiness
sysctl vm.swappiness
或者
cat /proc/sys/vm/swappiness

临时禁用swap
sysctl -w vm.swappiness=0

永久禁用swap
echo "vm.swappiness = 0">> /etc/sysctl.conf
sysctl -p
```
