# 一致性问题
举个例子，某影视公司旗下有西单和中关村的两个电影院，都出售某电影票，票一共就一万张。那么，顾客到达某个电影院买票的时候，售票员该怎么决策是否该卖这张票，才能避免超售呢？当电影院个数更多的时候呢？

在实际的计算机集群系统（看似强大的计算机系统，很多地方都比人类世界要脆弱的多）中，存在如下的问题：

```
节点之间的网络通讯是不可靠的，包括任意延迟和内容故障；
节点的处理可能是错误的，甚至节点自身随时可能宕机；
同步调用会让系统变得不具备可扩展性。
```

为了简化理解，仍然以两个电影院一起卖票的例子。可能有如下的解决思路：

```
每次要卖一张票前打电话给另外一家电影院，确认下当前票数并没超售；
两家电影院提前约好，奇数小时内一家可以卖票，偶数小时内另外一家可以卖；
成立一个第三方的存票机构，票都放到他那里，每次卖票找他询问；
```

规范的说，理想的分布式系统一致性应该满足：

```
可终止性（Termination）：一致的结果在有限时间内能完成；
共识性（Consensus）：不同节点最终完成决策的结果应该相同；
合法性（Validity）：决策的结果必须是其它进程提出的提案。
```

### 带约束的一致性
做过分布式系统的读者应该能意识到，绝对理想的强一致性（Strong Consistency）代价很大。除非不发生任何故障，所有节点之间的通信无需任何时间，这个时候其实就等价于一台机器了。实际上，越强的一致性要求往往意味着越弱的性能。一般的，强一致性（Strong Consistency）主要包括下面两类：

```
顺序一致性（Sequential Consistency）：Leslie Lamport 1979 年经典论文《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》中提出，是一种比较强的约束，保证所有进程看到的 全局执行顺序（total order）一致，并且每个进程看自身的执行（local order）跟实际发生顺序一致。例如，某进程先执行 A，后执行 B，则实际得到的全局结果中就应该为 A 在 B 前面，而不能反过来。同时所有其它进程在全局上也应该看到这个顺序。顺序一致性实际上限制了各进程内指令的偏序关系，但不在进程间按照物理时间进行全局排序。

线性一致性（Linearizability Consistency）：Maurice P. Herlihy 与 Jeannette M. Wing 在 1990 年经典论文《Linearizability: A Correctness Condition for Concurrent Objects》中共同提出，在顺序一致性前提下加强了进程间的操作排序，形成唯一的全局顺序（系统等价于是顺序执行，所有进程看到的所有操作的序列顺序都一致，并且跟实际发生顺序一致），是很强的原子性保证。但是比较难实现，目前基本上要么依赖于全局的时钟或锁，要么通过一些复杂算法实现，性能往往不高。
```

## 共识算法
往往需要某种共识算法来保证系统一致性，共识算法就是让系统中各个节点对某个提案达成一致。如果各个节点都能高性能无故障地运行，则只需要通过广播投票就能实现共识算法。可现实中往往会出现如响应时延、网络中断、节点故障、甚至存在恶意节点等问题。

一般地，把故障（不响应）的情况称为“非拜占庭错误”，恶意响应的情况称为“拜占庭错误”（对应节点为拜占庭节点）。针对非拜占庭错误的情况，一般包括 Paxos、Raft 及其变种。而对于要能容忍拜占庭错误的情况，一般包括 PBFT 系列、PoW 系列算法等。从概率角度，PBFT 系列算法是确定的，一旦达成共识就不可逆转；而 PoW 系列算法则是不确定的，随着时间推移，被推翻的概率越来越小。

即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题的下限是无解。这个结论，被称为 **FLP 不可能性** 原理。

## FLP 不可能性原理
  >FLP 不可能原理：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。

就是说，**不要浪费时间去为异步分布式系统设计在任意场景下都能实现共识的算法**。

理解这一原理的一个不严谨的例子是：三个人在不同房间，进行投票（投票结果是 0 或者 1）。三个人彼此可以通过电话进行沟通，但经常会有人时不时地睡着。比如某个时候，A 投票 0，B 投票 1，C 收到了两人的投票，然后 C 睡着了。A 和 B 则永远无法在有限时间内获知最终的结果。如果可以重新投票，则类似情形每次在取得结果前发生。


## CAP 原理
一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性；
可用性（Availablity）：在有限时间内，任何非失败节点都能应答请求；
分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。

分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。比较直观地理解，当网络可能出现分区时候，系统是无法同时保证一致性和可用性的。要么，节点收到请求后因为没有得到其他人的确认就不应答，要么节点只能应答非一致的结果。

对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设计。对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计,Paxos、Raft 等算法，主要处理这种情况。

## Paxos 与 Raft
故事背景是古希腊 Paxon 岛上的多个法官在一个大厅内对一个议案进行表决，如何达成统一的结果。他们之间通过服务人员来传递纸条，但法官可能离开或进入大厅，服务人员可能偷懒去睡觉。

Paxos 问题是指分布式的系统中存在故障但不存在恶意节点场景下的共识达成问题，被广泛应用在 Chubby、ZooKeeper 这样的系统中，Leslie Lamport 因此获得了 2013 年度图灵奖。Paxos算法中将节点分为三种类型。

```
1proposer：提出一个提案，等待大家批准为结案，往往是客户端担任该角色。
acceptor：负责对提案进行投票。往往是服务端担任该角色。
learner：被告知结案结果，并与之统一，不参与投票过程。可能为客户端或服务端。
```

算法需要保证决议结果是对的并且可以在有限时间内完成决议。基本过程包括 proposer 提出提案，先争取大多数 acceptor 的支持，超过一半支持时，则发送结案结果给所有人进行确认。一个潜在的问题是 proposer 在此过程中出现故障，可以通过超时机制来解决。极为凑巧的情况下，每次新的一轮提案的 proposer 都恰好故障，系统则永远无法达成一致（概率很小）。

如果系统中限定只有某个特定节点是提案者，那么一致性肯定能达成（只有一个方案，要么达成，要么失败）。如果只有一个接受者，共识也很容易达成，接收者收到多个提案，选第一个提案作为决议，拒绝掉后续的提案即可。但是在多个提案者且多个接收者的情况下问题就复杂了起来。

首先，同一时间片段内可以出现多个提案者。那同一个节点可能收到多份提案，怎么对他们进行区分呢？很自然的，提案需要带上不同的序号。节点只接受其中序号较大的提案。那么如何为提案分配序号呢？一种可能方案是每个节点的提案数字区间彼此隔离开，互相不冲突。为了满足递增的需求可以配合用时间戳作为前缀字段。
提案者发出提案之后，收到一些反馈。一种结果是自己的提案被大多数接受了，另一种结果是没被接受。没被接受的话好说，过会再试试。即便收到来自大多数的接受反馈，也不能认为就最终确认了。因为这些acceptor自己并不知道自己刚反馈的提案就恰好是全局的绝大多数。很自然的，引入了新的一个阶段，即提案者在前一阶段拿到所有的反馈后，判断这个提案是可能被大多数接受的提案，需要对其进行最终确认。Paxos 里面对这两个阶段分别命名为准备（prepare）和提交（commit）。准备阶段解决大家对哪个提案进行投票的问题，提交阶段解决确认最终值的问题。这种方式称为两阶段提交。

```
准备阶段：
提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多数接受者的支持。
接受者时刻保留收到过提案的最大编号和接受的最大提案。如果收到的提案号比目前保留的最大提案号还大，则返回自己已接受的提案值（如果还未接受过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接受小于最大提案号的提案。

提交阶段：
提案者如果收到大多数的回复（表示大部分人听到它的请求），则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功，则使用自己的提案内容；如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没收到足够多的回复，则需要再次发出请求。
接受者收到接受消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。
一旦多数接受了共同的提案值，则形成决议，成为最终确认的提案。
```

### Raft
Raft 算法是Paxos 算法的一种简化实现。
包括三种角色：leader、candidate 和 follower，其基本过程为：

Leader 选举：每个 candidate 随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为 leader；
同步 log：leader 会找到系统中 log 最新的记录，并强制所有的 follower 来刷新到这个记录；
注：此处 log 并非是指日志消息，而是各种事件的发生记录。

## 拜占庭问题与算法
拜占庭问题更为广泛，讨论的是允许存在少数节点作恶（消息可能被伪造）场景下的一致性达成问题。拜占庭算法讨论的是最坏情况下的保障。

中国将军问题
拜占庭将军问题之前，就已经存在中国将军问题：两个将军要通过信使来达成进攻还是撤退的约定，但信使可能迷路或被敌军阻拦（消息丢失或伪造），如何达成一致。根据 FLP 不可能原理，这个问题无解。

拜占庭问题
又叫拜占庭将军（Byzantine Generals Problem）问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。

拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。

对于拜占庭问题来说，假如节点总数为 N，叛变将军数为 F，则当 $$N \ge 3F+1$$ 时，问题才有解，即 Byzantine Fault Tolerant (BFT) 算法。

例如，$$N=3, F=1$$ 时。

提案人不是叛变者，提案人发送一个提案出来，叛变者可以宣称收到的是相反的命令。则对于第三个人（忠诚者）收到两个相反的消息，无法判断谁是叛变者，则系统无法达到一致。

提案人是叛变者，发送两个相反的提案分别给另外两人，另外两人都收到两个相反的消息，无法判断究竟谁是叛变者，则系统无法达到一致。

更一般的，当提案人不是叛变者，提案人提出提案信息 $$1$$，则对于合作者来看，系统中会有 $$N-F$$ 份确定的信息 $$1$$，和 $$F$$ 份不确定的信息（可能为 $$0$$ 或 $$1$$，假设叛变者会尽量干扰一致的达成），$$N-F > F$$，即 $$N > 2F$$ 情况下才能达成一致。

当提案人是叛变者，会尽量发送相反的提案给 $$N-F$$ 个合作者，从收到 $$1$$ 的合作者看来，系统中会存在 $$\frac{N-F}{2}$$ 个信息 $$1$$，以及 $$\frac{N-F}{2}$$ 个信息 $$0$$ ；从收到 $$0$$ 的合作者看来，系统中会存在 $$\frac{N-F}{2}$$ 个信息 $$0$$ ，以及 $$\frac{N-F}{2}$$ 个信息 $$1$$ ；

另外存在 $$F-1$$ 个不确定的信息。合作者要想达成一致，必须进一步的对所获得的消息进行判定，询问其他人某个被怀疑对象的消息值，并通过取多数来作为被怀疑者的信息值。这个过程可以进一步递归下去。

Leslie Lamport 证明，当叛变者不超过 $$\frac{1}{3}$$ 时，存在有效的算法，不论叛变者如何折腾，忠诚的将军们总能达成一致的结果。如果叛变者过多，则无法保证一定能达到一致性。

多于 $$\frac{1}{3}$$ 的叛变者时有没有可能有解决方案呢？设想 $$f$$ 个叛变者和 $$g$$ 个忠诚者，叛变者故意使坏，可以给出错误的结果，也可以不响应。某个时候 $$f$$ 个叛变者都不响应，则 $$g$$ 个忠诚者取多数既能得到正确结果。当 $$f$$ 个叛变者都给出一个恶意的提案，并且 $$g$$ 个忠诚者中有 $$f$$ 个离线时，剩下的 $$g - f$$ 个忠诚者此时无法分别是否混入了叛变者，仍然要确保取多数能得到正确结果，因此，$$g - f > f$$，即 $$g > 2f$$，所以系统整体规模要大于 $$3f$$。

能确保达成一致的拜占庭系统节点数至少为 4，允许出现 1 个坏的节点。

Byzantine Fault Tolerant 算法
面向拜占庭问题的容错算法，解决的是网络通信可靠，但节点可能故障情况下的一致性达成。

最早由 Castro 和 Liskov 在 1999 年提出的 Practical Byzantine Fault Tolerant（PBFT）是第一个得到广泛应用的 BFT 算法。只要系统中有 $$\frac{2}{3}$$ 的节点是正常工作的，则可以保证一致性。

PBFT 算法包括三个阶段来达成共识：Pre-Prepare、Prepare 和 Commit。

新的解决思路
拜占庭问题之所以难解，在于任何时候系统中都可能存在多个提案（因为提案成本很低），并且要完成最终的一致性确认过程十分困难，容易受干扰。但是一旦确认，即为最终确认。

比特币的区块链网络在设计时提出了创新的 PoW（Proof of Work） 算法思路。一个是限制一段时间内整个网络中出现提案的个数（增加提案成本），另外一个是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓宽。系统的最终确认是概率意义上的存在。这样，即便有人试图恶意破坏，也会付出很大的经济代价（付出超过系统一半的算力）。

后来的各种 PoX 系列算法，也都是沿着这个思路进行改进，采用经济上的惩罚来制约破坏者。

## 可靠性指标
那么，该如何提升可靠性呢？有两个思路：一是让系统中的单点变得更可靠；二是消灭单点。
