优化器选择索引的逻辑是：最小代价去执行语句。而扫描行数是一个关键因素，除此之外，优化器还会根据是否需要用临时表，是否排序等因素来判断。

优化器根据索引区分度来估算扫描行数，cardinality 越大，区分度越好。使用 show index 可以看到 cardinality。MySQL 通过采样统计估计 cardinality，默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。

索引统计值（cardinality 列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。
接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。

解决方案： analyze table t 命令，可以用来重新统计索引信息。
