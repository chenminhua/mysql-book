有序，可靠传输不丢包，连接控制，流量控制，拥塞控制。

基于字节流（无界）而非报文。双向。流量缓冲。

## 报文格式

- 来源端口（2 字节），目的端口（2 字节）
- 序列号（4 字节）
- 确认序号（4 字节，ACK 包特有）
- 数据偏移 + 保留位 + flag (2 字节)， 窗口大小（2 字节）
- checksum（2 字节）, 紧急指针（urg, 2 字节）
- optional

可见 TCP 报文头最小为 20 字节，可能更大。

- 每个包都有自己的序号，以解决乱序问题。初始序号在三次握手的时候确定。
- 内核在处理新的包时，只有当前面的包都已经到达，才会真正返回给用户进程，否则必须等待。
- ACK 包用于确认发出去的包已经收到。如果发出去的包没有收到 ACK，则发送端要进行重发。
- TCP 重传是传输层自己完成的，属于内核中 TCP 协议栈的工作，用户进程不必操心。
- ACK 机制解决了丢包的问题，让 TCP 比 UDP 更可靠。

接下来的一些 flag 位则标记了包的类型，比如 SYN 表示这个包是用来发起连接的，ACK 表示这是个应答包，RST 表示重新连接，FIN 表示结束连接。这些 flag 位解决了连接控制的问题。

窗口大小字段则是做流量控制的，通信一方根据自己的处理能力调整窗口大小，以控制对方的传输速度，让双方读和写的速度达到平衡。

## 三次握手

RFC https://tools.ietf.org/html/rfc793#page-30

```
      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

SYN 攻击：攻击方大量发送 SYN 请求给服务器，这会导致服务器产生大量 SYN_RCVD 状态的连接。

## 四次挥手

RFC https://tools.ietf.org/html/rfc793#section-3.5

![tcp 四次挥手](./images/tcp_finish.jpg)

为什么挥手一定是四次？其实四次挥手刚好是双方各发起了一次。

- 当 A 发起挥手后，它就进入了 FIN-WAIT1 状态，此时它再调用 SEND 都会被内核拒绝，但是它还是可以读数据的。
- B 在收到 A 发起的 FIN 后，它会先 ACK 给 A，让 A 进入 FIN-WAIT2 状态，而 B 自己进入 CLOSED-WAIT 状态。
- 此时 B 还可以发消息给 A，做一些善后工作，A 也还是可以收到 B 的包，但是它只能 ACK，不能发消息了。
- B 完成这些工作后，也发起断开 FIN，表示自己也准备好结束通话了，而自己则进入 LAST-ACK 状态，等待 A 最后的 ACK。
- A 收到 B 发来的 FIN 之后，回复这个 FIN 的 ACK，并进入 TIME-WAIT 状态，等待 2MSL 时间，然后正式关闭连接。
- B 收到 ACK 后也关闭这个连接。

如果 B 没有发那个 FIN 会怎么样？TCP 协议里面没有处理这种情况，而在 Linux 中，则有一个 tcp_fin_timeout 参数，来设置超时时间。

为什么 A 要等待 2MSL 的时间？因为如果 A 发送的最后一个 ACK 没有到达 B，B 就会重发这个 FIN 包，但是如果 A 这时候已经关闭连接了，B 就永远也收不到这个 ACK 了。因此 TCP 协议要求 A 最后等待一段时间，以应对 B 重发的 FIN 并返回 ACK。

等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。

## TCP 状态机

![TCP状态机](./images/tcp_statemachine.jpg)

## 工具

netstat -tulpn

## 连接控制

顺序问题与丢包问题

1、2、3 都是已发送并确认的。
4、5 接收方已经发出 ACK 了，但是发送方还没有收到（可能丢了或还在路上）。
6、7、8、9 都发出了，但是 8、9 先到了接收端而 6、7 还没到（丢包问题或乱序问题）。此时 8、9 只能先缓存着不能 ACK。

我们看到，顺序问题和丢包问题都可能发生，所以我们先来看看确认与重发机制。假设 4 的 ACK 到了，而 5 的 ACK 丢了，6、7 的数据包压根没到接收端，怎么办？

一种方式是超时重试，也就是对每个发送了但没有 ACK 的包设定定时器，超时就重发。这就需要选择一个合适的超时时间，而这需要 TCP 通过采样 RTT 时间（往返时间），然后加权平均。由于重传时间是不断变化的，称之为自适应重传算法。

假设如果过一段时间，5，6，7 都超时了，就都重新发送，接收方发现 5 已经收过了，就丢弃 5； 6 收到了就 ACK；7 比较惨，又丢了。当 7 再次超时并需要重传的时候，TCP 的策略是超时时间加倍。（连续超时说明网络环境差，不宜频繁发送）

还有一种快速重传的机制，当接收方收到一个序号大于下一个期望的报文段时，就检测到了数据流中的一个间隔，于是发送三个冗余的 ACK，发送方收到后就在定时器过期前重传丢失报文。例如接收方发现 7 没来，就发送三个 6 的 ACK，客户端收到后就立刻发送 7。

## 流量控制

RFC793 中指出，TCP 通过让接收端在每个 ACK 包中设置滑动窗口大小的方式，让接收端能够控制发送端发送数据的速率。

这个窗口被称为 receiver's advertised window，简称 rwnd。发送端缓存包含四个部分：

- 发送了并且已经收到 ACK 确认的
- 发送了但还没有确认的
- 还没发送，但是可以发送的
- 暂时还不能发送的

rwnd 的大小在发送端应该等于「发送了未确认」的部分，以及「未发送但可发送」的部分，超出窗口的部分都是「暂时不能发送的」。发送超过这个窗口大小的数据，可能导致接收端忙不过来。

接收端缓存要简单一些，包括：

- 接受并以及确认的。
- 还没接受，但是马上能接受的。（还没被应用程序读取）
- 暂时还没法接受的。

rwnd 是接收端决定的，它会怎么决定呢？假设接收端接收的数据一直在接收端缓存中，没有被应用程序读取，这时候就表明接收端处理不过来了，就要限制发送端发送速度，这样就导致在 ack 的过程中不断缩小 rwnd，直到为 0，发送端停止发送。

之后，发送方会定期发送探活包，看是否有机会调整窗口大小。

## 拥塞控制

除了怕把接收端缓存打满外，还需要担心将网络打满的问题。因此需要通过拥塞窗口来一起控制发送速度。

拥塞控制（congestion control）的设计并不在最初的 RFC793 中，而是在 RFC2001, RFC2581, RFC5681 中被详细描述。目前最新的 RFC 为 2009 年修订的[RFC5681](https://tools.ietf.org/html/rfc5681)。
如 RFC5681 文档所述，TCP 拥塞控制主要由四个部分组成，分别是 slow start, congestion avoidance, fast retransmit, fast recovery。

发送方怎么判断网络满不满呢？TCP 发包就是往水管里面灌水，而拥塞控制就是在不堵塞不丢包的情况下，尽量发挥带宽。
网络带宽就像水管粗细；网络延时就像水管长度。理想状态下，水管里面水量 = 水管粗细 \* 水管长度。
网络通道的容量 = 带宽 \* 往返延时。如果我们设置发送窗口，使得发送但未确认的包为通道容量，就能撑满整个管道。

假设往返时间为 8s，去 4s，回 4s。每秒发一个包，每个包 1024byte。已经过去了 8s，则 8 个包都发出去了，其中前 4 个到达接收端但 ACK 还没回来，后 4 个还在路上没被接收。这个时候管道刚好被撑满。（发送端已发送未确认的包为 8 个，正好等于带宽）

这时候如果我们加快发包速度，只会导致丢包或超时重传。**TCP 拥塞控制就是用来避免这两种现象的：丢包和超时重传。**

怎么知道要发多快呢？TCP 采用慢启动的策略：一条 TCP 连接开始，cwnd 设置为一个报文段一次只能发送一个，当收到这个包的确认后，cwnd 加 1，于是一次可以发送两个；而这两个每回来一个 cwnd 就加 1.当涨到 65535 个字节后，就放慢增长速度，变成线性增长了，每 ACK 一个包增长 1/cwnd。

**拥塞的一种表现形式是丢包，需要超时重传**，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。因此需要采用一种快速重传算法。当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。

就像前面说的一样，正是这种知进退，使得时延很重要的情况下，反而降低了速度。但是如果你仔细想一下，TCP 的拥塞控制主要来避免的两个现象都是有问题的。
第一个问题是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。
第二个问题是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。
为了优化这两个问题，后来有了 TCP BBR 拥塞算法。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。
