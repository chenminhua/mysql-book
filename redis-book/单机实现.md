## 服务器中的数据库

```c++
struct redisServer {
    redisDb *db;      // 一个数组，保存着服务器中的所有数据库
    int dbnum;        // 服务器的数据库数量 （默认会创建16个）
}
```

redis 客户端默认会选择 0 号数据库。客户端可以通过执行 SELECT 来选择数据库。服务器内部的 redisClient 结构的 db 属性记录当前客户端使用的数据库。

```c++
typedef struct redisClient {
    redisDb *db;
}
```

谨慎处理多数据库的程序，执行操作前先看清自己在操作哪个数据库。

```c++
struct redisDb {
    dict *dict;      // 数据库键空间，保存着数据库中所有键值对
    dict *expires;   // 过期字典，保存着键的过期时间
}
```

## 读写 key space 时候的维护操作

1. 读取一个键时，服务器会根据键是否存在来更新 keyspace_hits 和 keyspace_misses 属性，可以通过 INFO stats 来查看。

2. 读取一个键后，更新其 lru 时间。

3. 如果在读取一个键的时候发现其已经过期，会先删除这个键。

4. 如果有客户端使用 watch 命令监视了某个键，那么服务器在修改这个键的时候会将其标记为 dirty，从而让事务程序注意到这个键已经被修改。

5. 服务器每次修改一个键后，都会对脏键计数器加 1，这个计数器会触发持久化以及复制操作。

6. 如果开启了数据库通知功能，那么在对键进行修改后，服务器将按配置发送相应数据库通知。

## 设置 TTL 或过期时间

expire <key> 5 : 表示 5 秒后这个 key 过期
expireat <key> 1577257300 : 表示 key 的过期时间  
TTL <key> : 表示 key 还有多久会被删除
TIME : 返回系统时间

PERSIST 命令可以移除一个键的过期时间，方法很简单，就是去改 expires dict 里面对应的键的过期时间。

过期键删除策略： 定时删除（依赖定时器），惰性删除，定期删除。

Redis 采用 惰性删除 + 定期删除。

定期删除是每当 redis server 周期性操作 serverCron 函数执行时， activeExpireCycle 函数就会被调用。
它在规定时间内从数据库的 expires 字典中随机检查一部分键的过期时间。

## 持久化

https://redis.io/topics/persistence 认真阅读这一篇

## RDB 持久化

SAVE 命令直接阻塞服务器进程，BGSAVE 则会派生一个子进程来创建 RDB 文件。 SAVE 的地址是 /var/lib/redis/dump.rdb

RDB 文件的载入工作是在 redis-server 服务启动的时候自动加载的。启动日志里可以看到 DB loaded from disk:...

另外值得一提的是，因为 AOF 文件的更新频率通常比 RDB 文件高，所以如果服务器开了 AOF 持久化的话，优先使用 AOF 来还原数据。只有在 AOF 功能关闭的状态下才使用 RDB 文件还原数据库状态。

#### 自动间隔性保存

Redis 允许用户通过设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE。
比如 save 60 10000 表示在 60s 内对数据库进行了 10000 次写。

```
31999:M 22 Nov 2019 14:26:17.009 * 10000 changes in 60 seconds. Saving...
31999:M 22 Nov 2019 14:26:17.009 * Background saving started by pid 32039
32039:C 22 Nov 2019 14:26:17.015 * DB saved on disk
32039:C 22 Nov 2019 14:26:17.015 * RDB: 0 MB of memory used by copy-on-write
31999:M 22 Nov 2019 14:26:17.109 * Background saving terminated with success
```

```c++
struct redisServer {
    struct saveparam *saveparams;
    long long dirty;  // 修改次数
    time_t lastsave;  // 上次保存时间
}

struct saveparam {
    time_t seconds;    // 时间间隔
    int changes;       // 修改次数
}
```

redis 的周期性执行任务 serverCron 默认每 100ms 就会执行一次，对运行中的服务器进行维护。它的工作之一就是检查 save 条件是否满足，
如果满足则进行 bgsave。

## AOF 持久化

aof 的实现方式分为：命令追加，文件写入，文件同步

```c++
struct redisServer {
    sds aof_buf   // AOF缓冲区
}
```

AOF 文件的写入时机发生在 serverCron.

AOF 文件的写入与同步: 操作系统中，当调用 write 时，数据不是直接写到文件，而是写到了内存缓冲区，等缓冲区满了或者超出指定时间后，才真正写入磁盘。
这种做法可能会导致丢数据，为此，系统提供了 fsync 和 fdatasync 两个同步函数，可以强制冲刷数据到硬盘内，从而确保写入数据安全性。

appendfsync: always/everysec/no， 默认配置为 everysec。
always 表示每次写入都 flush。
everysec 表示如果上次 flush 到现在超过 1 秒，就 flush。
no 表示 flush 时间由操作系统决定。

trade-off between performance(availability) and consistency.

#### AOF 重写

解决 AOF 文件过大的问题。
BGREWRITEAOF。redis 会使用一个子进程处理这个请求。
为了保证一致性，redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程后开始使用，当 redis 服务器执行写后，会同时记录到 AOF 缓冲区和 AOF 重写缓冲区。
然后当新的 AOF 文件创建完成后，会把重写缓冲区的内容写入新的 AOF 文件，然后替换掉旧的 AOF 文件，整个 rewrite 过程只在这个过程中发生阻塞。

注意，不能在关闭 AOF 的情况下，直接修改 appendonly yes 并重启，因为这样会导致服务重启的时候不去读 dump.rdb 文件。

aof 文件在 /var/lib/redis/appendonly.aof

#### RDB VS AOF

一般来说，不考虑硬盘大小，最安全的做法是 RDB 与 AOF 同时使用，即使 AOF 损坏无法修复，还可以用 RDB 来恢复数据。

如果 Redis 的数据在你的服务中并不是必要的数据，例如只是当简单的缓存，没有缓存也不会造成缓存雪崩。说明数据的安全可靠性并不是首要考虑范围内，那么单独只使用 RDB 就可以了。

官方不推荐单独使用 AOF，因为 AOF 对于数据的恢复载入来说，比 RDB 慢。并且 Redis 官方也说明了，AOF 有一个罕见的 bug。出了问题无法很好的解决。所以使用 AOF 的时候，最好还是有 RDB 作为数据备份。

混合使用的方式

```
appendonly yes
aof-use-rdb-preamble yes
```

redis 5.0 开启 aof 的时候默认就是 aof + rdb
