### 隔离性与隔离级别

```
Read uncommitted:  事务还没提交，其做的改变就能被其他事务看到。
Read committed:    事务提交后，其做的改变才能被其他事务看到。
Repeatable read:   一个事务执行过程中看到的数据，总是和事务启动时看到的数据一致。
Serializable:      读操作会加读锁，写操作会加写锁。当出现写锁冲突时，只能一个一个事务来。
```

## 如何查看现在 mysql 正在使用的隔离级别

```ß
select @@tx_isolation       当前会话隔离级别
select @@global.tx_isolation     全局隔离级别

设置隔离级别
set session transaction isolation level read committed;
set global transaction isolation level read committed;
```

### 如何实现隔离

# DDIA CHAPTER 7

有些人抱怨，常用的两阶段提交在性能和可用性方面代价太高。而我们认为事务滥用和过度使用所引入的性能瓶颈应该主要由应用层来解决，而不是简单的抛弃事务。

数据存储可能存在的问题：
数据库软件或硬件可能随时会失效。
应用程序可能随时崩溃。
网络连接随时可能断开（应用与数据库间，数据库与数据库间）。
多个客户端可能同时写入数据，导致数据覆盖。
客户端可能读到一些部分更新的数据，这些数据可能是错误的，无意义的。

事务技术是简化这些问题的首选机制，事务将应用程序的多个读、写捆绑在一起成为一个逻辑操作单元。即事务中的所有读写是一个整体，要么全部成功，要么全部失败，而不能部分成功部分失败。

事务不是一个天然的东西，而是人为创造出来的，目的是简化应用程序编程模型。有了事务，程序员就不用管那些隐藏的可能出现的错误和复杂的并发问题，而将这些问题交给数据库。

为了判断是否需要事务，我们要先搞清楚，事务提供了哪些安全性保证，背后的代价是什么？

原子： 要么都做，要么都不做。
一致： 主要是指对数据有特定的预期状态，比如转账后与转账前两个账户的数量加和应该相等。一致性其实更多的是应用层的属性而非数据库自身属性。应用程序可以借助数据库事务的原子性、隔离性来实现一致性。
隔离： 隔离意味着并发执行的多个事务相互隔离，不能相互交叉，虽然实际上他们可能同时运行，但是数据库要保证数据提交时，其结果与串行运行一样。
持久： 一旦写入成功，即使数据库崩溃，数据也不能丢。

## 读提交

读数据时，只能读已经提交的数据（防止脏读）
写数据时，只能覆盖已经提交的数据（防止脏写）

关于防止脏读，一种思路是加读锁，但是在数据库场景下，这种思路显然不可行，因为这明显会拖慢事务。大多数数据库都采用 MVCC 来防止脏读，对于每个待更新的对象，数据库都会维持其旧值和新值两个版本。在事务提交之前，所有操作都读取旧值，事务提交后才能读新值。

关于脏写问题，数据库通常采用行级锁来实现，当事务想要修改某行时，它必须首先获得行锁，并持有到事务提交。如果有另一个事务也想改这行，则必须等待。这种锁定机制是读提交模式下数据库自动完成的。

## 读提交的问题 （不可重复读）

假设 Alice 在银行有 1000 美元存款，分两个账号，各 500 美元。然后她从账号 1 转了 100 美元到账号 2。但是在转账的过程中，她有可能在查自己账户的时候，会发现自己只有 900 美元了。这种现象就是**读倾斜**，也叫**不可重复读**。

在有些场景下，不可重复读不是什么大问题，但是有时候，可能会带来灾难。

## 可重复读

快照隔离级别是解决这个问题的关键，其总体想法是，每个事务都从数据库中的一致性快照中读取。事务一开始看到的是最近提交的数据，之后即使数据可能被另一个事务的提交改变，但是保证每个事务都只能看到特定时间的旧数据。

快照隔离级别对长时间运行的只读查询比较有用（备份、批处理分析）。

与读提交一样，可重复读采用行锁来防止脏写。但是读数据是不用加锁的，因为读都是在一致性快照上读取。这使得数据库在处理正常的写入时，在一致性快照上可以执行长时间的只读查询，两者之间没有任何锁竞争。

在 mysql 中，如果是 RR 隔离级别，事务启动时会创建一个 readview,之后有人改了数据，它再读也是看到事务启动时候的数据。
但是如果有个事务想更新一行但是被 block 了（拿不到写锁），那等他终于拿到这个锁的时候，看见的是啥？

**注意，在 MySQL 中，一致性快照并不是 start transaction 的时候创建的，而是在之后第一个操作 innodb 的语句的时候。如果你想在 start transaction 的时候立即创建快照，就需要 start transaction with consistent snapshot。**

```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);

tx1: start transaction with consistent snapshot
tx2: start transaction with consistent snapshot
tx3: update t set k = k + 1 where id = 1;   (auto commit)
tx2: update t set k = k+1 where id = 1;
tx2: select k from t where id = 1;
tx1: select k from t where id = 1; commit;
tx2: commit;
```

在上面的例子中，tx2 查 id=1 的 k 值为 3，而 tx1 查到的是 1。

在 mysql 中，有两个视图的概念：一个是 view，另一个是 innodb 的一致性读视图。

## How InnoDB MVCC works.

RR 下，事务启动时对整个数据库拍了个快照。

innodb 中每个事务都有唯一的 trx_id，是事务开始的时候申请的，严格递增。

每行数据都有多个版本，每次事务更新数据就会产生新版本，并把 trx_id 赋值给这个版本的事务 id，记为 row_trx_id。同时旧数据也会保留，并且在新版本中可以直接拿到旧版本数据。

也就是说，每行数据有多个版本 row,每个版本对应一个事务（对应一个 row_trx_id）。而这些版本，事实上是通过 undo log 来计算的。

如果事务 B 在更新前查数据，它看到的确实是 1，但是当它要去更新数据的时候，就不能在历史版本更新了，否则事务 C 的更新旧丢了。所以事务 B 是在当前数据而非历史版本上更新的。
这存在一条“当前读”规则：更新数据都是先读后写的，而且读的都是当前值（而非历史版本）。
除了 Update 外， select 语句加锁（ lock in share mode 或 for update）也是当前读。

【参考印象笔记】
