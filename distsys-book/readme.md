# 可扩展性与可用性

分布式系统关键在于提升两个方面的指标：Scalability 与 Avaliability。

#### Scalability （大流量问题，并发读并发写）

- 无状态业务进程的 Scalability 比较容易。有状态服务比较麻烦，常用方案有主从复制，partition 的方案等等。
- 读多的业务可以引入缓存层，减少对后端服务与存储的访问。
- 对于一致性要求不高的业务，可以采用异步削峰去谷，在大流量出现时避免上下游间相互影响。
- 总结：水平扩展，主从复制，partition，引入缓存，异步处理。

#### Availability （消除单点，提升可用性）

- 提升可用性，提高 SLA 的问题也应该从多个维度来考虑。首先最关键的是消除各个层面上的单点。
- 要对业务进行拆分，不同的业务有不同的 SLA，对可用性要求高的业务不可以依赖对可用性要求低的业务。
- 对服务做冗余，并实现弹性伸缩。
- 对于关键业务，我们一定要进行保护，在关键时刻进行限流或降级操作，先保证基本的可用性。
- 尽可能保证各个业务能够 **fail independently**，同时对于不能 fail 的服务则要做到高可用。
- 需要高可用的运维架构。
- 对于顶层设计能力的要求也变高了，你需要在一些关键指标之间做 trade-off，寻找对业务最关键的点。

#### 解耦

- 耦合是一个很常见的事，基本上来说，如果你知道一个服务是怎么做的，你就依赖了他，只是耦合轻或重的问题。
- 如果你直接调用了它的接口，你就很重的依赖了它，你的可用性也肯定比它低，如果它响应慢你就也跟着慢。
- 如果是消息队列，这时候如果你不知道对方存在，你就不依赖它了，但它是依赖你的，你哪天调用消息队列的代码出了 bug，它的业务就受影响了。

**微服务架构不过是一种部署选项，而好的架构在代码层面不应该关心软件是被如何部署的。** 服务如何运行和编排，不应该影响代码编写。我们最近就遇到一些将若干服务组合起来部署到其他环境中的需求，而且对于运行时的需求其实各个环境是不一样的。

循环依赖有很多的副作用，这是一种极强的耦合，会导致服务部署相当复杂和难解，而且会导致无穷尽的递归故障和一些你意想不到的问题。可以使用 zipkin, pinpoint, cat 等等 tracing 技术来梳理服务间的依赖关系。

# 分布式系统的关键技术

通常我们可以把整个系统分为四层：基础层，中间层，应用层，接入层。每一层出现问题都可能导致整个系统不可用，在层与层间需要设立规范。

- 基础层包括机器，存储等基础设施；
- 中间层则是 kafka，redis 等中间件；
- 应用层是我们的应用服务；
- 接入层是网关，LB, CDN，DNS 等。

而通过上面的分析，我们可以看到，引入分布式系统，会引入一堆技术问题，需要从以下几个方面来解决。

- 服务治理。服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。
- 架构软件管理。服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。
- DevOps。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。
- 自动化运维。对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。
- 资源调度管理。应用层的自动化运维需要 IaaS 层的计算、存储、网络等资源调度、隔离和管理。
- 整体架构监控。如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。
- 流量控制。负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。
- 好的软件项目需要大量的纪律，表的设计，接口的设计，日志的格式，协议的使用，命名空间的划分，配置的管理。
- 关于故障，分布式服务出故障的概率是很高的。可怕的不是出故障，而是故障恢复时间过长，以及故障影响面过大。
- 某个报表导出服务挂一会儿问题可能不大，但是用户中心如果挂了，可能整个系统都会收影响。对于那些特别重要的服务，防灾比救灾更重要，我们需要引入更多的保护机制，比如限流，降级等策略，防止核心服务被打挂。

# 一致性协议与 paxos

分布式系统的特点： 分布性，对等性，并发性，缺乏全局时钟，故障总会发生

分布式系统环境问题： 通信异常，节点故障，网络分区，三态问题。

BASE: basically available, soft state and eventually consistent。 基本可用，软状态，最终一致。

- 基本可用：响应时间上的损失，功能上的损失。
- 弱状态：允许系统在不同节点的副本间同步数据过程中存在延时。
- 最终一致：系统中所有副本在经过一段时间同步后，最终能够达到一致的状态。

### 一致性协议

2PC, 先准备后提交。2PC 的缺点：1. 同步阻塞，2. 存在单点，如果有人没收到提交请求，则还是会有数据不一致问题。

3PC, CanCommit -> PreCommit -> Commit

Paxos, 1990 年由 leslie lamport（2013 年图灵奖得主） 提出。拜占庭将军问题。《Paxos made simple》。
在古希腊有个叫 paxos 的岛，岛上采用议会形式来通过法令，议员们通过信使来传递消息。议员和信使都可能随时离开，并且信使可能传递重复的消息或丢弃消息。

Raft

### chubby: paxos 的工程实践

chubby 是 google 推出的分布式锁服务，GFS 和 Big Table 等大型系统都用它来解决分布式协作，元数据存储和 master 选举等问题。

《the chubby lock service for loosly-coupled distributed systems》

通过投票选举产生一个获得过半投票的服务器为 master，一旦产生了 master，chubby 就会保证在这段时间内不会再有其他服务器成为 master，这段时间称为租期（master lease）。

在运行过程中，master 会不停通过续租的方式来延长租期，如果 master 服务器出现故障，就会发生新一轮的 Master 选举。

集群中每个服务器都维护一个副本，但是只有 master 有权利 update，其他服务器只能从 master 同步更新。

chubby 客户端只和 master 进行通信，所有请求都发到 master,针对写，master 会广播给其他服务器，而读则由 master 亲自搞定。

## Quorum 机制： 过半机制
