- 什么情况下需要重试：调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。
- 不该重试的场景：业务级的错误（如没有权限），技术上的错误（503，可能是触发了 bug，重试下去没有意义）。

## 重试的策略

Exponential Backoff 策略，就是"指数级退避"。在这种情况下，每一次重试所需要的休息时间都会成倍增加。这种机制主要是用来让被调用方能够有更多的时间来从容处理我们的请求。这其实和 TCP 的拥塞控制有点像。
如果我们写成代码应该是下面这个样子。
首先，我们定义一个调用返回的枚举类型，其中包括了 5 种返回错误——成功 SUCCESS、维护中 NOT_READY、流控中 TOO_BUSY、没有资源 NO_RESOURCE、系统错误 SERVER_ERROR。
1
public enum Results {
2
SUCCESS,
3
NOT_READY,
4
TOO_BUSY,
5
NO_RESOURCE,
6
SERVER_ERROR
7
}
8

 复制代码
接下来，我们定义一个 Exponential Backoff 的函数，其返回 2 的指数。这样，每多一次重试就需要多等一段时间。如：第一次等 200ms，第二次要 400ms，第三次要等 800ms……
1
public static long getWaitTimeExp(int retryCount) {
2
long waitTime = ((long) Math.pow(2, retryCount) );
3
return waitTime;
4
}
 复制代码
下面是真正的重试逻辑。我们可以看到，在成功的情况下，以及不属于我们定义的错误下，我们是不需要重试的，而两次重试间需要等的时间是以指数上升的。
1
public static void doOperationAndWaitForResult() {
2

3
// Do some asynchronous operation.
4
long token = asyncOperation();
5

6
int retries = 0;
7
boolean retry = false;
8

9
do {
10
// Get the result of the asynchronous operation.
11
Results result = getAsyncOperationResult(token);
12

13
if (Results.SUCCESS == result) {
14
retry = false;
15
} else if ( (Results.NOT_READY == result) ||
16
(Results.TOO_BUSY == result) ||
17
(Results.NO_RESOURCE == result) ||
18
(Results.SERVER_ERROR == result) ) {
19
retry = true;
20
} else {
21
retry = false;
22
}
23
if (retry) {
24
long waitTime = Math.min(getWaitTimeExp(retries), MAX_WAIT_INTERVAL);
25
// Wait for the next Retry.
26
Thread.sleep(waitTime);
27
}
28
} while (retry && (retries++ < MAX_RETRIES));
29
}
30

 复制代码
上面的代码是非常基本的重试代码，没有什么新鲜的，我们来看看 Spring 中所支持的一些重试策略。
Spring 的重试策略
Spring Retry 是一个单独实现重试功能的项目，我们可以通过 Annotation 的方式使用。具体如下。
1
@Service
2
public interface MyService {
3
@Retryable(
4
value = { SQLException.class },
5
maxAttempts = 2,
6
backoff = @Backoff(delay = 5000))
7
void retryService(String sql) throws SQLException;
8
...
9
}
 复制代码
配置 @Retryable 注解，只对 SQLException 的异常进行重试，重试两次，每次延时 5000ms。相关的细节可以看相应的文档。我在这里，只想让你看一下 Spring 有哪些重试的策略。
NeverRetryPolicy：只允许调用 RetryCallback 一次，不允许重试。
AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环。
SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为 3 次，RetryTemplate 默认使用的策略。
TimeoutRetryPolicy：超时时间重试策略，默认超时时间为 1 秒，在指定的超时时间内允许重试。
CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置 3 个参数 openTimeout、resetTimeout 和 delegate；关于熔断，会在后面描述。
CompositeRetryPolicy：组合重试策略。有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即不可以。但不管哪种组合方式，组合中的每一个策略都会执行。
关于 Backoff 的策略如下。
NoBackOffPolicy：无退避算法策略，即当重试时是立即重试；
FixedBackOffPolicy：固定时间的退避策略，需设置参数 sleeper 和 backOffPeriod，sleeper 指定等待策略，默认是 Thread.sleep，即线程休眠，backOffPeriod 指定休眠时间，默认 1 秒。
UniformRandomBackOffPolicy：随机时间退避策略，需设置 sleeper、minBackOffPeriod 和 maxBackOffPeriod。该策略在 [minBackOffPeriod, maxBackOffPeriod] 之间取一个随机休眠时间，minBackOffPeriod 默认为 500 毫秒，maxBackOffPeriod 默认为 1500 毫秒。
ExponentialBackOffPolicy：指数退避策略，需设置参数 sleeper、initialInterval、maxInterval 和 multiplier。initialInterval 指定初始休眠时间，默认为 100 毫秒。maxInterval 指定最大休眠时间，默认为 30 秒。multiplier 指定乘数，即下一次休眠时间为当前休眠时间 \*multiplier。
ExponentialRandomBackOffPolicy：随机指数退避策略，引入随机乘数，之前说过固定乘数可能会引起很多服务同时重试导致 DDos，使用随机休眠时间来避免这种情况。
重试设计的重点
重试的设计重点主要如下：
要确定什么样的错误下需要重试；
重试的时间和重试的次数。这种在不同的情况下要有不同的考量。有时候，而对一些不是很重要的问题时，我们应该更快失败而不是重试一段时间若干次。比如一个前端的交互需要用到后端的服务。这种情况下，在面对错误的时候，应该快速失败报错（比如：网络错误请重试）。而面对其它的一些错误，比如流控，那么应该使用指数退避的方式，以避免造成更多的流量。
如果超过重试次数，或是一段时间，那么重试就没有意义了。这个时候，说明这个错误不是一个短暂的错误，那么我们对于新来的请求，就没有必要再进行重试了，这个时候对新的请求直接返回错误就好了。但是，这样一来，如果后端恢复了，我们怎么知道呢，此时需要使用我们的熔断设计了。这个在后面会说。
重试还需要考虑被调用方是否有幂等的设计。如果没有，那么重试是不安全的，可能会导致一个相同的操作被执行多次。
重试的代码比较简单也比较通用，完全可以不用侵入到业务代码中。这里有两个模式。一个是代码级的，像 Java 那样可以使用 Annotation 的方式（在 Spring 中你可以用到这样的注解），如果没有注解也可以包装在底层库或是 SDK 库中不需要让上层业务感知到。另外一种是走 Service Mesh 的方式（关于 Service Mesh 的方式，我会在后面的文章中介绍）。
对于有事务相关的操作。我们可能会希望能重试成功，而不至于走业务补偿那样的复杂的回退流程。对此，我们可能需要一个比较长的时间来做重试，但是我们需要保存请求的上下文，这可能对程序的运行有比较大的开销，因此，有一些设计会先把这样的上下文暂存在本机或是数据库中，然后腾出资源来做别的事，过一会再回来把之前的请求从存储中捞出来重试。
小结
好了，我们来总结一下今天分享的主要内容。首先，我讲了重试的场景，比如流控，但并不是所有的失败场景都适合重试。接着我讲了重试的策略，包括简单的指数退避策略，和 Spring 实现的多种策略。
这些策略可以用 Java 的 Annotation 来实现，或者用 Service Mesh 的方式，从而不必写在业务逻辑里。最后，我总结了重试设计的重点。下篇文章中，我们讲述熔断设计。希望对你有帮助。
