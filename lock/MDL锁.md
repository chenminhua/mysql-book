MDL 锁在访问一个表的时候自动被加上，用来保证读写的正确性。
想象一下一个查询正在遍历一个表中的数据，而在此期间另一个线程对这个表进行了列删除，这个查询线程拿到的结果和表结构对不上了，肯定不行啊。
因此 mysql5.5 引入了 MDL。当对一个表进行增删改查操作时，加 MDL 读锁；当对表结构变更的时候，加 MDL 写锁。

## 加字段 (给小表加字段小心导致 Mysql 崩溃)

给表加字段，改字段，加索引什么的，都会导致全表扫描，并且还要加 MDL 写锁。

假设你有一个表，在 MDL 前正在进行一些请求，其中有些请求开了个事务，而且这个事务还贼长（比如你在搞备份的时候开了个超长事务）。这时候表上是有 MDL 读锁的。i
然后你执行表更新操作，需要加 MDL 写锁，而由于前面的事务没有提交，所以这个写锁被阻塞了，你要等到前面的 MDL 读锁释放了才能执行表更新操作。
更糟糕的是，后面的所有增删改查都需要获取 MDL 读锁，但是由于 MDL 写锁的存在，它们也都被阻塞了。如果你的客户端还有重试机制，很快数据库就跪了。

1. 遇到这种情况，首先你要搞定长事务，事务不提交，就会一直占着 MDL 锁。你可以在 information_schema 库的 innodb_trx 表中查询长事务，比如查询持续时间超过 60s 的事务。

```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

2. 如果你要变更的表是个热点表，这个时候 kill 掉事务可能也没有用，比较理想的机制是在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

## Online DDL

Online DDL 的机制是

```
1. 拿 MDL 写锁
2. 降级成 MDL 读锁
3. 执行 DDL
4. 升级成 MDL 写锁
5. 释放 MDL 锁
```
