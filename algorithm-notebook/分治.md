合并 k 个链表

```java

public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) return null;
    return merge(lists, 0, lists.length - 1);
}

private ListNode merge(ListNode[] lists, int left, int right) {
    if (left == right) return lists[left];
    int mid = left + (right - left) / 2;
    ListNode l1 = merge(lists, left, mid);
    ListNode l2 = merge(lists, mid + 1, right);
    return mergeTwoLists(l1, l2);
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;
    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1,l2.next);
        return l2;
    }
}
```

## 链表的归并排序 LC 148

```java
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode mid = findMiddle(head);
    ListNode tmp = mid.next;
    mid.next = null;
    return merge(sortList(head), sortList(tmp));
}

private ListNode findMiddle(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode fast = head.next;
    ListNode slow = head;

    while(fast!= null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

private ListNode merge(ListNode n1, ListNode n2) {
    ListNode h = new ListNode(0);
    ListNode p = h;
    while(n1 != null && n2 != null) {
        if(n1.val < n2.val) {
            p.next = n1;
            n1 = n1.next;
        } else {
            p.next = n2;
            n2 = n2.next;
        }
        p = p.next;
    }
    if(n1 != null) p.next = n1;
    if (n2 != null) p.next = n2;
    return h.next;
}
```
