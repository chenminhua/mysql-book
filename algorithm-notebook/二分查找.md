https://www.youtube.com/watch?v=v57lNF2mb_s&list=PLLuMmzMTgVK74vqU7Ukaf70a382dzF3Uo&index=9

```py
# 区间 [l, r)
def binary_search(l, r):
    while l < r:
        m  = l + (r - l) // 2
        if f(m): return m
        if g(m):
            r = m        # [l, m)
        else:
            l = m + 1    # [m+1, r)
    return l # or not found

# lower bound
def lower_bound(array, val):
    l = 0
    r = len(array)
    while l < r:
        m  = l + (r - l) // 2
        if array[m] >= val:
            r = m
        else:
            l = m + 1
    return l

# upper bound
def upper_bound(array, val):
    l = 0
    r = len(array)
    while l < r:
        m = l + (r - l) // 2
        if array[m] > val:
            r = m
        else:
            l = m + 1
    return l

# LC 69 SQRT(x)
def sqrt(x):
    l = 0
    r =  x+1
    while l < r:
        m = l + (r - l) // 2
        if m * m > x:
            r = m
        else:
            l = m + 1
    return l - 1

# lc 278, first bad version
def firstBadVersion(n):
    l = 0
    r = n
    while l < r:
        m = l + (r - l) // 2
        if isBadVersion(m)
            r = m
        else
            l = m + 1
    return l

# lc 875 koko eating bananas
def eat(piles, H):
    l = 1
    r = max(piles) + 1
    while l < r:
        m = l + (r - l) // 2
        h = 0
        for p in piles:
            h += (p + m - 1) / m
        if h <= H:
            r = m
        else
            l = m + 1
    return l

# lc 378 kth smallest element in a sorted matrix
def kthSmallest(A, k):
    l  = A[0][0]
    r = A[-1][-1]
    while l < r:
        m  = l + (r - l) // 2
        total = 0
        for row in A:
            total += upper_bound(row, m)
        if total >= k
            r = m
        else
            l = m + 1
    return l
```

java

```java
// https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/
public int minArray(int[] numbers) {
    int len = numbers.length;
    if (len == 0) {
        return 0;
    }
    int left = 0;
    int right = len - 1;
    while (left < right) {
        int mid = (left + right) >>> 1;
        if (numbers[mid] > numbers[right]) {
            // [3, 4, 5, 1, 2]，mid 以及 mid 的左边一定不是最小数字
            // 下一轮搜索区间是 [mid + 1, right]
            left = mid + 1;
        } else if (numbers[mid] == numbers[right]) {
            // 只能把 right 排除掉，下一轮搜索区间是 [left, right - 1]
            right = right - 1;
        } else {
            // 此时 numbers[mid] < numbers[right]
            // mid 的右边一定不是最小数字，mid 有可能是，下一轮搜索区间是 [left, mid]
            right = mid;
        }
    }

    // 最小数字一定在数组中，因此不用后处理
    return numbers[left];
}
```
