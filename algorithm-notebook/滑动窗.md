- 滑动窗问题通常是在一维空间寻找最优解，往往包含关键词「最大」、「最小」、「最长」等等。
- 这类题目通常会采用两个指针来表示窗口，头指针用于扩展，尾指针用于收缩。
- 收缩的时候，有时可采用 hashMap 或者索引数组等方式优化。

#### LC3 无重复字符最长子串

比如 "abcabcbb"，其中无重复字符最长子串的长度就是 3。此题思路很经典，采用了滑动窗搜索的技巧（头部扩展，尾部收缩），并利用 hashMap 存储索引位置优化窗口收缩。

可以用滑动窗解决这个问题。起始时将滑动窗头尾指针都指向字符串头部，然后头指针向前进，当遇到窗内存在的字符时，收缩窗尾。比如 "fabcabad"，当我们的窗头访问到第二个 a 的时候，需要将窗尾收缩到第一个 b 的位置，以确保窗内所有字符都只有一个。

标记一个字符是否在窗内存在，我们想到 set。但是我们还需要知道当字符再次出现的时候窗尾收缩的位置，所以我们可以考虑用一个 hashMap 来存储，其中 key 是字符，而 val 是字符上一次出现的位置。

#### LC159 最多包含两个不同字符的最长子串

这题和上面那题差不多，就是滑动窗+hashMap.

除此之外，LC340 把「两个不同字符」改成「k 个不同字符」，换汤不换药。

#### LC76 最小覆盖子串

- 给定字符串 S 和 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。
- 比如 S = "ADOBECODEBANC", T = "ABC"。输出: "BANC"。

两个字符串，有点模式匹配的意思哈。光看匹配比较容易先往 Hash 算法上想，但是在这个题上比较难，因为"abbbc"和"ac"都是"ac"的覆盖子串。你需要设计一种只和 target 串里面出现的字符有关的 hash 算法，并且能够完美解决哈希冲突。

换一个简单点的思路，先用 map 来存模式串中的字符出现频率。比如"AAB"对应的 map 就是{A: 2, B: 1}，目标就是在目标串中找到满足这个 map 的子串。还是可以用两层循环来穷举所有的子串。但这实在太蠢了，因为目标是找最小覆盖子串（上一题是最大），很多搜索都是不必要的。

我们还是用一样的滑动窗技巧，头部不断扩展来将新的字符加入窗体内。同时用一个 map 来记录窗体内的字符频率。

假设我们一开始计算好的模式串的频率表叫 targetMap，窗体内的频率表叫 windowMap，我们还需要不断比较 windowMap 里面是否包含了 targetMap 的所有 key，且每个 value 都比它大。

这里我们可以再进行一个优化，以写代读的优化。我们可以在每次更新 windowMap 的时候和 targetMap 进行比较，并用一个数字记录 windowMap 满足 targetMap 的 key 数，当 key 数等于 targetMap 的总 Key 数后，我们就认为找到了一个匹配的模式子串。而一旦形成了一个覆盖子串，我们就开始收缩，直到子串不再匹配之后，窗头才能继续前进。

其实这题和前两天还是一个模子里出来的，滑动窗+hashMap，只是在匹配判断和收缩的时候加了一点技巧。

```java
public String minWindow(String s, String t) {
    if (s.length() == 0 || t.length() == 0) return "";
    Map<Character, Integer> dictT = new HashMap();      // target string char dict
    for (int i = 0; i < t.length(); i++) dictT.put(t.charAt(i), dictT.getOrDefault(t.charAt(i), 0) + 1);
    int required = dictT.size(), formed = 0;    // number of unique chars
    Map<Character, Integer> windowCounts = new HashMap();  // 窗口内字符统计

    // ans list of the form (window length, left, right)
    int[] ans = {-1, 0 , 0};

    int l = 0, r = 0;    // 滑动窗的双指针
    while (r < s.length()) {
        char c = s.charAt(r);
        if (!dictT.containsKey(c)) {r++; continue;}
        windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);
        if (windowCounts.get(c).intValue() == dictT.get(c).intValue()) formed++;

        // 如果字符收集够了，可以开始收缩了
        while(l <= r && formed == required) {
            c = s.charAt(l);
            if (ans[0] == -1 || r - l + 1 < ans[0]) {
                ans[0] = r - l + 1;
                ans[1] = l;
                ans[2] = r;
            }
            if (dictT.containsKey(c)) {
                windowCounts.put(c, windowCounts.get(c) - 1);
                if (windowCounts.get(c).intValue() < dictT.get(c).intValue()) formed--;
            }

            l++;
        }
        r++;
    }

    return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);

}
```

#### LC 727 最小窗口子序列

看起来和 76 题差不多，但不是覆盖，而是子序列（对字符出现顺序有要求）。hashMap 计数的方式显然不行。

我们分两部分来考虑，首先是如何找到一个符合要求的子串（窗口）。我们还是从头开始出发，分别用两个指针，一个指向模式串的头，一个指向目标串的头。目标串的指针不断向前，如果匹配到模式串的当前字符，就将模式串指针也向前移动。直到模式串指针走完，我们就找打了一个匹配子串。

第二个问题是，如何找到最短。也就是如果收缩子串。这里有一个技巧和之前不一样，我们不是用一个指针从头再走过来一遍，而是从最后一个字符的位置开始反向匹配，这样就能找到最小的窗口。

#### LC 239 滑动窗最大值

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字，求每个窗口中最大值。比如输入数组 [1,3,-1,-3,5,3,6,7]，窗口大小为 3，输出为[3,3,5,5,6,7]。

这题和上面三题就有区别了，窗口大小是固定的。

一个办法是模拟滑动窗的滑动过程，维护一个链表存储窗口中的所有数。然后每次移动都计算链表中的最大值。这个方法有个问题，如果窗口太大的话，每次计算都会很耗时。

我们可以改造一下窗口，让窗口里面的值保持从左往右是递减的，这样，我们每次从窗口取值就从左边取就好了。

为了实现这一点，我们在往窗口里面加值的时候（从右边），需要先比较加入的值和右边值的大小，如果加入的值比右边的值大，则需要将原来右边的值去掉。此外，我们需要判断左边的值是否已经在窗口外了，所以我们需要将每个值的索引和值一起加入窗口，在收缩的时候，将索引超出窗口范围的值移除。

总结：此题思路还是比较简单的，难点在于改造窗口，在扩展窗口的时候需要丢弃没有用的值，在收缩的时候需要根据索引来判断。

## LC395 至少有 K 个重复字符的最长子串
